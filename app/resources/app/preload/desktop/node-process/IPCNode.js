const{EventEmitter:EventEmitter}=require("events"),{getIPCHandle:getIPCHandle,getResponseChannels:getResponseChannels}=require("./ipcUtils"),{createConnection:createConnection}=require("net"),{NodeSocket:NodeSocket}=require("./NodeSocket"),{Protocol:Protocol}=require("./Protocol"),{CommunicationChannel:CommunicationChannel}=require("./Channel");function createClient(e){return new Promise(((n,t)=>{const o=createConnection(e,(()=>{o.removeListener("error",t),n(o)}));o.once("error",t)}))}class IPCNode extends EventEmitter{constructor(e,n){super(),this._logger=n,this.namedPipe=getIPCHandle(e),createClient(this.namedPipe).then((e=>{const n=new NodeSocket(e,this._logger),t=new Protocol(n,this._logger);this._commChannel=new CommunicationChannel(t,this._logger),this._commChannel.onMessage((e=>{"error"!==e.channel&&this.emit(e.channel,...e.args)})),this._commChannel.onClose((()=>{this.emit("close")})),this.emit("connect")})).catch((e=>{this._logger.error("IPCNode~createClient~something wrong connecting to the IPC server",e)})),this.on("error",(e=>{this._logger.error("IPCNode~something is wrong",e)}))}dispose(){this._commChannel.dispose()}onConnect(e){return this.on("connect",e),()=>{this.removeListener("connect",e)}}onClose(e){return this.on("close",e),()=>{this.removeListener("close",e)}}subscribe(e,n){return this.on(e,n),()=>{this.removeListener(e,n)}}subscribeOnce(e,n){let t=!1;const o=this.subscribe(e,((...e)=>{if(t)return o();t=!0,n(...e)}))}send(e,...n){const t={channel:e,args:n};return this._commChannel.send(t)}invoke(e,...n){const t=new Promise(((t,o)=>{const r=getResponseChannels(e);n.push(r),this.subscribeOnce(r.data,t),this.subscribeOnce(r.error,o)}));return this.send(e,...n),t}}module.exports={IPCNode:IPCNode};