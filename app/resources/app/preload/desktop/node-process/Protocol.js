const{EventEmitter:EventEmitter}=require("events"),{PMBuffer:PMBuffer}=require("./PMBuffer");let emptyBuffer=null;function getEmptyBuffer(){return emptyBuffer||(emptyBuffer=PMBuffer.alloc(0)),emptyBuffer}class ChunkStream{get byteLength(){return this._totalLength}constructor(){this._chunks=[],this._totalLength=0}acceptChunk(t){this._chunks.push(t),this._totalLength+=t.byteLength}read(t){if(0===t)return getEmptyBuffer();if(t>this._totalLength)throw new Error("Cannot read so many bytes!");if(this._chunks[0].byteLength===t){const e=this._chunks[0];return this._chunks.shift(),this._totalLength-=t,e}if(this._chunks[0].byteLength>t){const e=this._chunks[0].slice(0,t);return this._chunks[0]=this._chunks[0].slice(t),this._totalLength-=t,e}let e=PMBuffer.alloc(t),s=0;for(;t>0;){const i=this._chunks[0];if(i.byteLength>t){const h=i.slice(0,t);e.set(h,s),s+=t,this._chunks[0]=i.slice(t),this._totalLength-=t,t-=t}else e.set(i,s),s+=i.byteLength,this._chunks.shift(),this._totalLength-=i.byteLength,t-=i.byteLength}return e}}class ProtocolReader extends EventEmitter{constructor(t,e){super(),this._socket=t,this._logger=e,this._isDisposed=!1,this._incomingData=new ChunkStream,this._socket.onData((t=>this.acceptChunk(t))),this._state={readLen:4,readHead:!0}}onMessage(t){return this.on("message",t),{dispose:()=>this.removeListener("message",t)}}acceptChunk(t){if(t&&0!==t.byteLength)for(this._incomingData.acceptChunk(t);this._incomingData.byteLength>=this._state.readLen;){const t=this._incomingData.read(this._state.readLen);if(this._state.readHead)this._state.readHead=!1,this._state.readLen=t.readUInt32BE(0);else if(this._state.readHead=!0,this._state.readLen=4,this.emit("message",PMBuffer.wrap(t)),this._isDisposed)break}}dispose(){this._isDisposed=!0}}class ProtocolWriter{constructor(t){this._isDisposed=!1,this._socket=t,this._data=[],this._totalLength=0}dispose(){this.flush(),this._isDisposed=!0}flush(){this._writeNow()}write(t){if(this._isDisposed)return;const e=PMBuffer.alloc(4);e.writeUInt32BE(t.byteLength,0),this._writeSoon(e,t)}_bufferAdd(t,e){const s=0===this._totalLength;return this._data.push(t,e),this._totalLength+=t.byteLength+e.byteLength,s}_bufferTake(){const t=PMBuffer.concat(this._data,this._totalLength);return this._data.length=0,this._totalLength=0,t}_writeSoon(t,e){this._bufferAdd(t,e)&&setImmediate((()=>{this._writeNow()}))}_writeNow(){0!==this._totalLength&&this._socket.write(this._bufferTake())}}class Protocol extends EventEmitter{constructor(t){super(),this._socket=t,this._socketWriter=new ProtocolWriter(this._socket),this._socketReader=new ProtocolReader(this._socket),this._socketReader.onMessage((t=>{this.emit("message",t)})),this._socket.onClose((()=>this.emit("close")))}dispose(){this._socketReader.dispose(),this._socketWriter.dispose(),this._socket.dispose()}onMessage(t){return this.on("message",t),{dispose:()=>this.removeListener("message",t)}}getSocket(){return this._socket}send(t){this._socketWriter.write(t)}onClose(t){return this.on("close",t),{dispose:()=>this.removeListener("close",t)}}}module.exports={Protocol:Protocol};