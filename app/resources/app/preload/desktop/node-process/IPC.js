const{EventEmitter:EventEmitter}=require("events"),fs=require("fs"),{createServer:createServer}=require("net"),{CommunicationChannel:CommunicationChannel}=require("./Channel"),{Protocol:Protocol}=require("./Protocol"),{NodeSocket:NodeSocket}=require("./NodeSocket"),{getIPCHandle:getIPCHandle}=require("./ipcUtils");function createIpcServer(e,r){function n(n){fs.unlink(e,(e=>e?(r.error("IPC~closePipe~could not unlink pipe",e),n&&n(e)):(r.info("IPC~closePipe~IPC server is closing"),n&&n(null))))}return new Promise(((t,o)=>{function s(t){if("EADDRINUSE"!==t.code)return o(t);r.info("IPC~handleServerCreationError~IPC server pipe in use, retrying..."),n((n=>{if(n)return r.error("IPC~handleServerCreationError~could not close the IPC server",n),o(n);i.listen(e)}))}const i=createServer();i.on("close",(()=>{n()})),i.on("error",s),i.on("listening",(()=>(r.info("IPC~Ipc server started listening"),i.removeListener("error",s),t(i)))),i.listen(e)}))}class IPC extends EventEmitter{constructor(e,r){super(),this._logger=r,this.namedPipe=getIPCHandle(e),this._commChannels=[],createIpcServer(this.namedPipe,this._logger).then((e=>{this._server=e,this._server.on("connection",(e=>{const r=new NodeSocket(e,this._logger),n=new Protocol(r,this._logger),t=new CommunicationChannel(n,this._logger);t.onMessage((e=>{if("error"===e.channel)return;const r={reply:(e,...r)=>{this._send(t,e,...r)}};this.emit(e.channel,r,...e.args)})),t.onClose((()=>{this._commChannels=this._commChannels.filter((e=>e!==t))})),this._commChannels.push(t)})),this._server.on("close",(()=>{this.emit("close")})),this.emit("ready")})).catch((e=>{this._logger.error("IPC~createIpcServer~something wrong creating the IPC server",e)})),this.on("error",(e=>{this._logger.error("IPC~something is wrong",e)}))}onReady(e){return this.on("ready",e),()=>{this.removeListener("ready",e)}}onClose(e){return this.on("close",e),()=>{this.removeListener("close",e)}}subscribe(e,r){return this.on(e,r),()=>{this.removeListener(e,r)}}subscribeOnce(e,r){let n=!1;const t=this.subscribe(e,((e,...o)=>{if(n)return t();n=!0,r(e,...o)}))}_send(e,r,...n){const t={channel:r,args:n};return e&&e.send(t)}broadcast(e,...r){for(let n=0;n<this._commChannels.length;n++)this._send(this._commChannels[n],e,...r)}handle(e,r){return this.subscribe(e,(async(e,...n)=>{const t=n.pop();try{const o=await r(e,...n);e.reply(t.data,o)}catch(r){e.reply(t.error,r)}}))}handleOnce(e,r){return this.subscribeOnce(e,(async(e,...n)=>{const t=n.pop();try{const o=await r(e,...n);e.reply(t.data,o)}catch(r){e.reply(t.error,r)}}))}}module.exports={IPC:IPC};