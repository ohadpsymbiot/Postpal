"use strict";(self.webpackChunk_postman_app_renderer=self.webpackChunk_postman_app_renderer||[]).push([[73],{"./collaboration/components/access-request/ApprovalPage.js":function(e,t,s){s.r(t);var r=s("../../node_modules/react/index.js"),o=s("./collaboration/services/AccessRequestService.js"),a=s("./js/services/NavigationService.js"),c=s("./js/navigation/active-mode/constants.js"),n=s("./js/components/base/LoadingIndicator.js"),i=s("./js/stores/CurrentUserStore.js"),l=s("./js/stores/StoreManager.js"),u=s("./js/stores/SyncStatusStore.js"),d=s("../../node_modules/mobx/lib/mobx.module.js"),p=s("./collaboration/constants/accessRequests.js"),m=s("./node_modules/lodash/lodash.js");t.default=({controller:e})=>{const[t,s]=(0,r.useState)(!1),y=(0,l.resolveStoreInstance)(u.default);return(0,r.useEffect)((()=>{const t=(0,d.reaction)((()=>(0,l.resolveStoreInstance)(i.default).teamId),(r=>{r&&((async e=>{s(!0);try{await y.onSyncAvailable();let t=await o.default.approve(e),{createdBy:r,modelName:n,model:u,displayNameForRole:d}=t||{},m=(0,l.resolveStoreInstance)(i.default).teamMembers.get(r)||{},f=`${m.name||m.username||m.email} is now ${d} on ${n} ${p.ACCESS_REQUEST_ENTITY_DISPLAY_NAME_MAP[u]||u}`;pm.toasts.success(f)}catch(e){const t=m.get(e,"error.name",""),s=p.ACCESS_REQUEST_ERROR_MAP[t]||{errorTitle:"Unable to approve request",errorMessage:"Whoops! It looks like you cannot approve this request."};pm.toasts.info(s.errorMessage,{title:s.errorTitle})}finally{s(!1),a.default.transitionTo(c.HOME)}})(e.queryParams.code),t&&t())}),{fireImmediately:!0});return()=>{t&&t()}}),[]),r.createElement(n.default,null)}},"./collaboration/controllers/AccessRequestPageController.js":function(e,t,s){s.r(t);var r=s("./appsdk/pages/BasePageController.js");class o extends r.default{didActivate({queryParams:e}){this.queryParams=e}}t.default=o},"./collaboration/services/AccessRequestService.js":function(e,t,s){s.r(t);var r=s("./node_modules/lodash/lodash.js"),o=s.n(r),a=s("./js/modules/services/RemoteSyncRequestService.js"),c=s("./js/utils/PostmanGatewayService.js"),n=s("./collaboration/workspace/utils/Workspace.ts");const i={approve:async e=>{if(!e)return Promise.reject(new Error("AccessRequestService~approve: Required param not send, code missing"));try{const t=await a.default.request("/ws/proxy",{method:"post",data:{path:`/access-requests/${e}/approve`,service:"collaboration",method:"post"}});return t.body&&t.body.data}catch(e){return pm.logger.warn("AccessRequestService~approve: Failed to approve request",e),Promise.reject(e)}},fetchCreated:async({entityId:e,entityType:t})=>{if(!e||!t)return Promise.reject(new Error("AccessRequestService~fetchCreated: Required params are missing"));try{const s=await a.default.request("/ws/proxy",{method:"post",data:{path:"/access-requests",service:"collaboration",method:"get",query:{model:t,modelId:e}}});return o().get(s,"body.data")}catch(e){return pm.logger.warn("AccessRequestService~fetchCreated: Failed to fetch created access requests",e),Promise.reject(e)}},create:async({approverId:e,role:t,entityType:s,entityId:r,context:c})=>{if(!(r&&s&&e&&t&&c))return Promise.reject(new Error("AccessRequestService~create: Required params are missing"));const n={model:s,modelId:r,context:c,approvers:[{type:"user",id:e}],role:t};try{const e=await a.default.request("/ws/proxy",{method:"post",data:{path:"/access-requests/create",service:"collaboration",method:"post",body:n}});return o().get(e,"body.data")}catch(e){return pm.logger.warn("AccessRequestService~create: Failed to create request for access",e),Promise.reject(e)}},fetchRequestApprovers:async({entityId:e,entityType:t})=>{if(!e||!t)return Promise.reject(new Error("AccessRequestService~fetchRequestApprovers: Required params are missing"));const s={"filter.objectType":t,"filter.objectId":e,"filter.permission":`UPDATE_${o().toUpper(o().snakeCase(t))}_ROLES`,"filter.entityTypes":"user,group"},r=n.default.convertToStringParams(s);try{const e=await a.default.request("/ws/proxy",{method:"post",data:{path:`/api/v1/entities?${r}`,service:"acs",method:"get"}});return o().get(e,"body")}catch(e){return pm.logger.warn("AccessRequestService~fetchRequestApprovers: Failed to fetch request approvers of model",e),Promise.reject(e)}},fetchUsersRoles:async({entityId:e,entityType:t})=>{if(!e||!t)return Promise.reject(new Error("AccessRequestService~fetchUsersRoles: Required params are missing"));const s={item:{objectType:t,objectId:e,entityType:["user"]}};try{const e=await a.default.request("/ws/proxy",{method:"post",data:{path:"/api/roles/list-by-object",service:"acs",method:"post",body:s}});return{roles:{user:i.formatRoles(o().get(e,"body.listing.user",{}))}}}catch(e){return pm.logger.warn("AccessRequestService~fetchUsersRoles: Failed to fetch users roles of model",e),Promise.reject(e)}},fetchRoles:async e=>{if(!e)return Promise.reject(new Error("AccessRequestService~fetchRoles: Required params are missing"));try{return(await c.default.request("/ws/proxy",{method:"post",body:{path:"/api/roles/list/by-objects",service:"acs",method:"post",body:{objects:[e]},query:{permissions:!1,populate:!0,type:"all"}}},{parsedResponse:!0,transformRequestJson:!0})).body}catch(e){return pm.logger.warn("AccessRequestService~fetchRoles: Failed to fetch roles for model",e),Promise.reject(e)}},formatRoles:e=>{if(!e)return pm.logger.warn("AccessRequestService~formatRoles: Required params are missing"),{};return o().reduce(e,((e,t,s)=>(e[s]=t.roles||[],e)),{})}};t.default=i}}]);